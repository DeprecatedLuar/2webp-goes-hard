#!/bin/bash
# Convert images to WebP with metadata preservation
# Usage: 2webp ow <folder>                    - Replace originals in-place
#        2webp cp <source> [destination]      - Copy structure to new location
#        2webp cp <source> [destination] -A   - Copy structure + all other files

# Quality settings (Settings are fine tuned based on experimentation)
HEIC_QUALITY=78
JPEG_QUALITY=50
PNG_QUALITY=76

# Tracking counters
ERROR_COUNT=0
SKIPPED_COUNT=0
CONVERTED_COUNT=0

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

# Handle Ctrl+C
trap 'echo -e "\n${RED}Operation cancelled${NC}"; exit 1' INT

# set -e

# Check/install ImageMagick
if ! command -v convert >/dev/null; then
    read -p "ImageMagick required. Install? (y/n): " choice
    [ "$choice" = "y" ] || { echo -e "${RED}Error: ImageMagick required${NC}" >&2; exit 1; }
    sudo apt update && sudo apt install -y imagemagick
fi

# Parse arguments
COMMAND="$1"
SOURCE_PATH="$2"
DESTINATION="$3"
COPY_ALL="$4"

# Usage function
usage() {
    echo -e "${RED}Usage:${NC}"
    echo "  $0 ow <folder>                    - Replace originals in-place"
    echo "  $0 cp <source> [destination]      - Copy structure to new location"
    echo "  $0 cp <source> [destination] -A   - Copy structure + all other files"
    exit 1
}

# Validate command
case "$COMMAND" in
    "ow")
        [ -z "$SOURCE_PATH" ] && usage
        [ ! -d "$SOURCE_PATH" ] && { echo -e "${RED}Error: '$SOURCE_PATH' not found${NC}" >&2; exit 1; }
        OUTPUT_PATH="$SOURCE_PATH"
        MODE="overwrite"
        ;;
    "cp")
        [ -z "$SOURCE_PATH" ] && usage
        [ ! -d "$SOURCE_PATH" ] && { echo -e "${RED}Error: '$SOURCE_PATH' not found${NC}" >&2; exit 1; }

        # Handle destination logic
        if [ -z "$DESTINATION" ]; then
            # Default: ~/2webp/foldername/
            folder_name=$(basename "$SOURCE_PATH")
            OUTPUT_PATH="$HOME/2webp/$folder_name"
        else
            # Check if destination is actually -A flag
            if [ "$DESTINATION" = "-A" ]; then
                folder_name=$(basename "$SOURCE_PATH")
                OUTPUT_PATH="$HOME/2webp/$folder_name"
                COPY_ALL="-A"
            else
                OUTPUT_PATH="$DESTINATION"
            fi
        fi

        mkdir -p "$OUTPUT_PATH"
        MODE="copy"
        ;;
    *)
        usage
        ;;
esac

# Check for rsync if -A flag is used
if [ "$COPY_ALL" = "-A" ] && ! command -v rsync >/dev/null; then
    read -p "rsync required for -A flag. Install? (y/n): " choice
    [ "$choice" = "y" ] || { echo -e "${RED}Error: rsync required for -A flag${NC}" >&2; exit 1; }
    sudo apt update && sudo apt install -y rsync
fi

# Copy non-image files if -A flag specified
if [ "$COPY_ALL" = "-A" ] && [ "$MODE" = "copy" ]; then
    echo "Copying non-image files..."
    # Copy everything except images, preserving structure and metadata
    (cd "$SOURCE_PATH" && rsync -a --exclude="*.jpg" --exclude="*.jpeg" --exclude="*.png" --exclude="*.heic" --exclude="*.heif" \
          --exclude="*.JPG" --exclude="*.JPEG" --exclude="*.PNG" --exclude="*.HEIC" --exclude="*.HEIF" \
          . "$OUTPUT_PATH/")
    echo -e "${GREEN}Non-image files copied${NC}"
fi

# Convert function
convert_type() {
    local pattern="$1" quality="$2" name="$3"
    echo "Processing $name files..."
    while IFS= read -r -d '' file; do
        # Ensure SOURCE_PATH ends with /
        source_with_slash="${SOURCE_PATH%/}/"
        relative_path="${file#$source_with_slash}"
        output_file="$OUTPUT_PATH/${relative_path%.*}.webp"
        mkdir -p "$(dirname "$output_file")"

        # Skip if exact file already exists (resumption support)
        if [ -f "$output_file" ]; then
            ((SKIPPED_COUNT++))
            continue
        fi

        # Create temporary file for atomic operation
        temp_file="${output_file%.webp}_tmp.webp"

        if convert "$file" -quality "$quality" "$temp_file" 2>/dev/null; then
            # Verify conversion succeeded and file has content
            if [ -s "$temp_file" ]; then
                # Atomic move to final destination
                mv "$temp_file" "$output_file"
                touch -r "$file" "$output_file"
                [ "$MODE" = "overwrite" ] && rm "$file"
                ((CONVERTED_COUNT++))
            else
                echo -e "${RED}Failed: $relative_path (empty output)${NC}" >&2
                rm -f "$temp_file"
                ((ERROR_COUNT++))
            fi
        else
            echo -e "${RED}Failed: $relative_path${NC}" >&2
            rm -f "$temp_file"
            ((ERROR_COUNT++))
        fi
    done < <(eval "find \"$SOURCE_PATH\" -type f $pattern -print0")
    echo -e "${GREEN}$name files completed${NC}"
}

# Process by type
convert_type '\( -iname "*.heic" -o -iname "*.heif" \)' "$HEIC_QUALITY" "HEIC"
convert_type '\( -iname "*.jpg" -o -iname "*.jpeg" \)' "$JPEG_QUALITY" "JPEG"
convert_type '-iname "*.png"' "$PNG_QUALITY" "PNG"

# Final summary
TOTAL_PROCESSED=$((CONVERTED_COUNT + SKIPPED_COUNT + ERROR_COUNT))
echo "Conversion complete"
echo ""
echo "$TOTAL_PROCESSED processed | $CONVERTED_COUNT converted | $SKIPPED_COUNT skipped | $ERROR_COUNT failed"
[ "$MODE" = "copy" ] && echo "Output: $OUTPUT_PATH"